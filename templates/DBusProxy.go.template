// Code generated by goqface. DO NOT EDIT.
package {{module.module.name_parts[-1]|lower}}

import (
{% for interface in module.interfaces: %}
{% if interface.properties %}
    "reflect"
{% endif %}
    "log"
{% endfor %}
	"github.com/godbus/dbus/v5"
{% for key, value in module.interface_imports.items() %}
{{key}} "{{value}}"
{% endfor %}
)

{% for interface in module.interfaces: %}

type {{interface.proxy_name}} struct {
	{% for property in interface.properties %}
	{{property.lower_name}} {{property.go_type}}
	{% endfor %}
	{% for property in interface.properties %}
	{{property.lower_name}}ChangedObservers []interface{ On{{property.cap_name}}Changed( {{property.name}} {{property.go_type}})}
	{% endfor %}
	readyChangedObservers []interface{ OnReadyChanged( ready bool)}
	{% for signal in interface.signals %}
    {{signal.lower_name}}Observers []interface{ On{{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) }
    {% endfor %}
	ready          bool
	Conn           *dbus.Conn
	ServiceName    string
	InterfaceName  string
	ObjectPath     dbus.ObjectPath
	RemoteObj      dbus.BusObject

}

func (c *{{interface.proxy_name}}) Init() {
    c.InterfaceName = "{{interface.qualified_name}}"
    c.ObjectPath = "/{{interface.qualified_name.replace('.', '/')}}"
}

func (c *{{interface.proxy_name}}) watchSignals() {
    ch := make(chan *dbus.Signal)
	c.Conn.Signal(ch)
	for v := range ch {
	    if (v.Name == "org.freedesktop.DBus.Properties.PropertiesChanged") {
	        var inter string
	        var changedProps map[string]dbus.Variant
	        var invalidatedProps []string
			err := dbus.Store(v.Body, &inter, &changedProps, &invalidatedProps)
			if err == nil && inter == "{{interface.qualified_name}}" {
                c.setProps(changedProps)
            } else if err != nil {
                log.Print(err)
            }
	    }
	    {% for signal in interface.signals %}
	    if (v.Name == "{{interface.qualified_name}}.{{signal.name}}") {
            {% for param in signal.parameters %}
            var arg{{loop.index}} {{param.go_type}}
            {% endfor %}
            err := dbus.Store(v.Body, {%- for parameter in signal.parameters -%} &arg{{loop.index}},{%- endfor -%})
            if err == nil {
                for _, observer := range c.{{signal.lower_name}}Observers {
                    go observer.On{{signal.cap_name}}({%- for parameter in signal.parameters -%} arg{{loop.index}},{%- endfor -%})
                }
            } else {
                log.Print(err)
            }
	    }
        {% endfor %}
	}
}

func (c *{{interface.proxy_name}}) ConnectToServer(serviceName string) {
    c.ServiceName = serviceName
    c.RemoteObj = c.Conn.Object(c.ServiceName, c.ObjectPath)
    values := c.RemoteObj.Call("org.freedesktop.DBus.Properties.GetAll", 0, c.InterfaceName)
	if len(values.Body) > 0 {
		props := values.Body[0].(map[string]dbus.Variant)
        c.setProps(props)
	}

   	c.RemoteObj.AddMatchSignal("org.freedesktop.DBus.Properties", "PropertiesChanged")
{% for signal in interface.signals %}
	c.RemoteObj.AddMatchSignal(c.InterfaceName, "{{signal.name}}")
{% endfor %}
    go c.watchSignals()
}

func (c *{{interface.proxy_name}}) setProps(props map[string]dbus.Variant) {
    {% for property in interface.properties %}
    if val, ok := props["{{property.name}}"]; ok {
        var t {{property.go_type}}
        err := dbus.Store([]interface{}{val}, &t)
        if err == nil && !reflect.DeepEqual(c.{{property.lower_name}}, t) {
            c.{{property.lower_name}} = t
            for _, observer := range c.{{property.lower_name}}ChangedObservers {
                go observer.On{{property.cap_name}}Changed(c.{{property.lower_name}})
            }
        } else if err != nil {
            log.Print(err)
        }
    }
    {% endfor %}
    if val, ok := props["ready"]; ok {
        dbus.Store([]interface{}{val}, &c.ready)
        for _, observer := range c.readyChangedObservers {
            go observer.OnReadyChanged(c.ready)
        }
    }
}

{% for property in interface.properties %}
func (c *{{interface.proxy_name}}) {{property.cap_name}}() {{property.go_type}} {
    return  c.{{property.lower_name}}
}
{% if not property.readonly %}
func (c *{{interface.proxy_name}}) Set{{property.cap_name}}(value {{property.go_type}}) error {
    return c.RemoteObj.SetProperty("{{interface.qualified_name}}.{{property.name}}", dbus.MakeVariant(value))
}
{% endif %}
{% endfor %}
func (c *{{interface.proxy_name}}) Ready() bool {
    return  c.ready
}

{% for property in interface.properties %}
func (c *{{interface.proxy_name}}) Add{{property.cap_name}}ChangedObserver(observer interface{ On{{property.cap_name}}Changed({{property.go_type}}) }) {
    c.{{property.lower_name}}ChangedObservers = append(c.{{property.lower_name}}ChangedObservers, observer)
}
func (c *{{interface.proxy_name}}) Remove{{property.cap_name}}ChangedObserver(observer interface{ }) bool {
    found := false
    for i := range c.{{property.lower_name}}ChangedObservers {
        if c.{{property.lower_name}}ChangedObservers[i] == observer {
            c.{{property.lower_name}}ChangedObservers = append(c.{{property.lower_name}}ChangedObservers[:i], c.{{property.lower_name}}ChangedObservers[i+1:]...)
            found = true
        }
     }
     return found
}
{% endfor %}

{% for signal in interface.signals %}
func (c *{{interface.proxy_name}}) Add{{signal.cap_name}}Observer(observer interface { On{{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) })  {
    c.{{signal.lower_name}}Observers = append(c.{{signal.lower_name}}Observers, observer)
}
func (c *{{interface.proxy_name}}) Remove{{signal.cap_name}}Observer(observer interface{ }) bool {
    found := false
    for i := range c.{{signal.lower_name}}Observers {
        if c.{{signal.lower_name}}Observers[i] == observer {
            c.{{signal.lower_name}}Observers = append(c.{{signal.lower_name}}Observers[:i], c.{{signal.lower_name}}Observers[i+1:]...)
            found = true
        }
     }
     return found
}
{% endfor %}

{% for operation in interface.operations %}
func (c *{{interface.proxy_name}}) {{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}} {{parameter.go_type}},{%- endfor -%}) ({% if operation.has_return_value %}r {{operation.go_type}}, {% endif %}err error){
    err=c.RemoteObj.Call("{{operation.name}}", 0, {%- for parameter in operation.parameters -%}{{parameter.name}},{%- endfor -%}){% if operation.has_return_value %}.Store(&r){% else %}.Err{% endif %}

    return {% if operation.has_return_value %}r, {% endif %}err
}
{% endfor %}

{% endfor %}

// Code generated by goqface. DO NOT EDIT.
package {{module.module.name_parts[-1]|lower}}
import (
	"reflect"
	"strings"

	"github.com/godbus/dbus/v5"
	"github.com/godbus/dbus/v5/introspect"
	"github.com/godbus/dbus/v5/prop"
{% for key, value in module.interface_imports.items() %}
{{key}} "{{value}}"
{% endfor %}
)

{% for interface in module.interfaces: %}
type {{interface.export_name}} interface {
{% for operation in interface.operations %}
{% if operation.comment %}
{{operation.comment}}
{% endif %}
{{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}} {{parameter.go_type}},{%- endfor -%}) ({% if operation.has_return_value %}{{operation.go_type}}, {% endif %}*dbus.Error)
{% endfor %}
}

type {{interface.cap_name}} struct {
    concreteImpl {{interface.export_name}}
	{% for property in interface.properties %}
	{{property.lower_name}} {{property.go_type}}
	{% endfor %}
	ready          bool // to be used to query readiness of the server
	Conn           *dbus.Conn
	InterfaceName  string
	ObjectPath     dbus.ObjectPath
	MethodMapping  map[string]string
	Props          *prop.Properties
	PropsSpec      map[string]map[string]*prop.Prop
}

/*
* init initializes the struct with the proper values
*/
func (c *{{interface.cap_name}}) Init(v {{interface.export_name}}) {
    c.concreteImpl = v
    c.InterfaceName = "{{interface.qualified_name}}"
    c.ObjectPath = "/{{interface.qualified_name.replace('.', '/')}}"
    c.MethodMapping = map[string]string{
    {% for operation in interface.operations %}
    "{{operation.cap_name}}": "{{operation.lower_name}}",
    {% endfor %}
    }

    c.PropsSpec = map[string]map[string]*prop.Prop{
		c.InterfaceName: {
            {% for property in interface.properties %}
            "{{property.name}}": {
                Value: &c.{{property.lower_name}},
                {% if property.readonly %}
                Writable: false,
                {% else %}
                Writable: true,
                {% endif %}
                Emit: prop.EmitTrue,
                {% if property.readonly %}
                Callback: nil,
                {% else %}
                Callback: set{{property.lower_name}}Callback(c),
                {% endif %}
            },
            {% endfor %}
			// a conventional property to be used on client side to check the connection and readiness of the server
			"ready": {
				Value: &c.ready,
				Writable: false,
				Emit: prop.EmitTrue,
				Callback: nil,
			},
		},
	}
}

func (c *{{interface.cap_name}}) Export() {
    c.Conn.ExportWithMap(c.concreteImpl, c.MethodMapping, c.ObjectPath, c.InterfaceName)
	props, err := prop.Export(c.Conn, c.ObjectPath, c.PropsSpec)
	if err != nil {
		panic(err)
	}
	c.Props = props
	methods := introspect.Methods(c.concreteImpl) // returns methods in uppercase, maybe a PR to godbus to have MethodsWihtMapping
    i := 0
    for _, method := range methods {
        mappedName, ok := c.MethodMapping[method.Name]
        if ok {
            method.Name = mappedName
            methods[i] = method
            i++
        }
    }
	methods = methods[:i]
	n := &introspect.Node{
		Name: string(c.ObjectPath),
		Interfaces: []introspect.Interface{
			introspect.IntrospectData,
			prop.IntrospectData,
			{
				Name:       c.InterfaceName,
				Methods:    methods,
				Signals:    c.signalsIntrospection(),
				Properties: props.Introspection(c.InterfaceName),
			},
		},
	}
	c.Conn.Export(introspect.NewIntrospectable(n), c.ObjectPath,
		"org.freedesktop.DBus.Introspectable")
}

{% for property in interface.properties %}
func (c *{{interface.cap_name}}) {{property.cap_name}} () {{property.go_type}} {
    return  c.{{property.lower_name}}
}
// assigns a new value to {{property.name}}
// updates the corresponding dbus property value
// emits the PropertiesChanged signal with the new value if EmitTrue
func (c *{{interface.cap_name}}) Assign{{property.cap_name}} (v {{property.go_type}}) {
    c.{{property.lower_name}} = v;
    c.Props.SetMust(c.InterfaceName, "{{property.name}}", v)
}

{% if not property.readonly %}
// creates the Callback function to hook into SetProperty sequence
// created Callback function changes the {{interface.lower_name}}.{{property.name}}
// calls {{property.name}}AboutToBeSet of concreteImpl, given implemented, to override the default behaviour
func set{{property.lower_name}}Callback(c *{{interface.cap_name}}) func(change *prop.Change) *dbus.Error {
    return func(change *prop.Change) *dbus.Error {
        var value {{property.go_type}}
		if err := dbus.Store([]interface{}{change.Value}, &value); err != nil {
			return dbus.MakeFailedError(err)
		}
		i, ok := c.concreteImpl.(interface{ {{property.cap_name}}AboutToBeSet({{property.go_type}}) error })
		if ok {
			if err := i.{{property.cap_name}}AboutToBeSet(value); err != nil {
			    return dbus.MakeFailedError(err)
			}
		}
		c.{{property.lower_name}} = value
		return nil
	}
}

{% endif %}
{% endfor %}

{% for signal in interface.signals %}
func (c *{{interface.cap_name}}) {{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) {
	c.Conn.Emit(c.ObjectPath, c.InterfaceName+".{{signal}}",
    {%- for parameter in signal.parameters -%}{{parameter.name}},{%- endfor -%})
}
{% endfor %}

func (c *{{interface.cap_name}}) signalsIntrospection() []introspect.Signal {
	t := reflect.TypeOf(c)
	signals := map[string][]string{ {% for signal in interface.signals %}"{{signal.name}}":{
	{%- for parameter in signal.parameters -%}"{{parameter.name}}",{%- endfor -%} },
	{% endfor %} }
	ms := make([]introspect.Signal, 0, len(signals))
    for k, v := range signals {
		signal, b := t.MethodByName(strings.Title(k))
		if !b {
			panic("something wrong in generated code")
		}
		var m introspect.Signal
		m.Name = k
		m.Args = make([]introspect.Arg, 0, signal.Type.NumIn())
		for j, param := range v {
			arg := introspect.Arg{Name: param, Type: dbus.SignatureOfType(signal.Type.In(j + 1)).String(), Direction: "out"}
			m.Args = append(m.Args, arg)
		}
		m.Annotations = make([]introspect.Annotation, 0)
		ms = append(ms, m)
	}
	return ms
}



{% endfor %}

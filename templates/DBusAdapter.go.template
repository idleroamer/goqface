// Code generated by goqface. DO NOT EDIT.
package {{module.module.name_parts[-1]|lower}}
import (
	"reflect"
	"strings"
{% for interface in module.interfaces: %}
{% if interface.properties %}
	"log"
{% endif %}
{% endfor %}
	"github.com/godbus/dbus/v5"
	"github.com/godbus/dbus/v5/introspect"
	"github.com/godbus/dbus/v5/prop"
	"github.com/idleroamer/goqface/objectManager"
{% for key, value in module.interface_imports.items() %}
{{key}} "{{value}}"
{% endfor %}
)

{% for interface in module.interfaces: %}
type {{interface.cap_name}} interface {
{% for operation in interface.operations %}
{% if operation.comment %}
{{operation.comment}}
{% endif %}
{{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}} {{parameter.go_type}},{%- endfor -%}) ({% if operation.has_return_value %}{{operation.go_type}}, {% endif %}*dbus.Error)
{% endfor %}
}

type {{interface.cap_name}}Adapter struct {
    interfaceImpl {{interface.cap_name}}
	{% for property in interface.properties %}
	{{property.lower_name}} {{property.go_type}}
	{% endfor %}
	{% for property in interface.properties %}
    {% if not property.readonly %}
    set{{property.cap_name}}Callback interface{ Set{{property.cap_name}}({{property.name}} {{property.go_type}}) error}
    {{property.lower_name}}ChangedObservers []interface{ On{{property.cap_name}}Changed( {{property.name}} {{property.go_type}})}
    {% endif %}
    {% endfor %}
	ready          bool // to be used to query readiness of the server
	Conn           *dbus.Conn
	interfaceName  string
	objectPath     dbus.ObjectPath
	MethodMapping  map[string]string
	Props          *prop.Properties
	PropsSpec      map[string]map[string]*prop.Prop
}

/*
* init initializes the struct with the proper values
*/
func (c *{{interface.cap_name}}Adapter) Init(v {{interface.cap_name}}) {
    c.interfaceImpl = v
	if c.interfaceName == "" {
    	c.interfaceName = "{{interface.qualified_name}}"
	}
	if c.objectPath == "" {
    	c.objectPath = "/{{interface.qualified_name.replace('.', '/')}}"
	}
    c.MethodMapping = map[string]string{
    {% for operation in interface.operations %}
    "{{operation.cap_name}}": "{{operation.lower_name}}",
    {% endfor %}
    }

    c.PropsSpec = map[string]map[string]*prop.Prop{
		c.interfaceName: {
            {% for property in interface.properties %}
            "{{property.name}}": {
                Value: &c.{{property.lower_name}},
                {% if property.readonly %}
                Writable: false,
                {% else %}
                Writable: true,
                {% endif %}
                Emit: prop.EmitTrue,
                {% if property.readonly %}
                Callback: nil,
                {% else %}
                Callback: set{{property.cap_name}}Callback(c),
                {% endif %}
            },
            {% endfor %}
			// a conventional property to be used on client side to check the connection and readiness of the server
			"ready": {
				Value: &c.ready,
				Writable: false,
				Emit: prop.EmitTrue,
				Callback: nil,
			},
		},
	}
}

func (c *{{interface.cap_name}}Adapter) Export() {
    c.Conn.ExportWithMap(c, c.MethodMapping, c.objectPath, c.interfaceName)
	props, err := prop.Export(c.Conn, c.objectPath, c.PropsSpec)
	c.Props = props
	if err != nil {
		panic(err)
	}
	c.Conn.ExportWithMap(c, map[string]string{"Introspect": "Introspect"}, c.objectPath, "org.freedesktop.DBus.Introspectable")
	goqface.ObjectManager(c.Conn).RegisterObject(c.ObjectPath(), nil)
}

func (c *{{interface.cap_name}}Adapter) ObjectPath() dbus.ObjectPath {
	return c.objectPath
}

func (c *{{interface.cap_name}}Adapter) InterfaceName() string {
	return c.interfaceName
}

func (c *{{interface.cap_name}}Adapter) Introspect() (string, *dbus.Error) {
	methods := introspect.Methods(c.interfaceImpl)
    i := 0
    for _, method := range methods {
        mappedName, ok := c.MethodMapping[method.Name]
        if ok {
            method.Name = mappedName
            methods[i] = method
            i++
        }
    }
	methods = methods[:i]
	n := &introspect.Node{
		Name: string(c.objectPath),
		Interfaces: []introspect.Interface{
			introspect.IntrospectData,
			prop.IntrospectData,
			{
				Name:       c.interfaceName,
				Methods:    methods,
				Signals:    c.signalsIntrospection(),
				Properties: c.Props.Introspection(c.interfaceName),
			},
		},
	}
	return string(introspect.NewIntrospectable(n)), nil
}

{% for operation in interface.operations %}
{% if operation.comment %}
{% endif %}
func (c *{{interface.cap_name}}Adapter) {{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}} {{parameter.go_type}},{%- endfor -%}) ({% if operation.has_return_value %}{{operation.go_type}}, {% endif %}*dbus.Error) {
	return c.interfaceImpl.{{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}},{%- endfor -%})
}
{% endfor %}

func (c *{{interface.cap_name}}Adapter) Ready() bool {
    return  c.ready
}
// assigns a new value to ready
// updates the corresponding dbus property value
// emits the PropertiesChanged signal with the new value if EmitTrue
func (c *{{interface.cap_name}}Adapter) AssignReady (v bool) {
    c.ready = v;
    c.Props.SetMust(c.interfaceName, "ready", v)
}

{% for property in interface.properties %}
func (c *{{interface.cap_name}}Adapter) {{property.cap_name}}() {{property.go_type}} {
    return  c.{{property.lower_name}}
}
// assigns a new value to {{property.name}}
// updates the corresponding dbus property value
// emits the PropertiesChanged signal with the new value if EmitTrue
func (c *{{interface.cap_name}}Adapter) Assign{{property.cap_name}} (v {{property.go_type}}) {
    c.{{property.lower_name}} = v;
    c.Props.SetMust(c.interfaceName, "{{property.name}}", v)
}

{% if not property.readonly %}
func (c *{{interface.cap_name}}Adapter) Set{{property.cap_name}}Callback(callback interface{ Set{{property.cap_name}}({{property.name}} {{property.go_type}}) error}) {
    c.set{{property.cap_name}}Callback = callback;
}
// creates the Callback function to hook into SetProperty sequence
// created Callback function changes the {{interface.lower_name}}.{{property.name}}
// calls Set{{property.name}}, given callback set, to check the value
func set{{property.cap_name}}Callback(c *{{interface.cap_name}}Adapter) func(change *prop.Change) *dbus.Error {
    return func(change *prop.Change) *dbus.Error {
        var value {{property.go_type}}
		if err := dbus.Store([]interface{}{change.Value}, &value); err != nil {
			return dbus.MakeFailedError(err)
		} else {
			log.Print(err)
		}
		if c.set{{property.cap_name}}Callback != nil {
		    if err := c.set{{property.cap_name}}Callback.Set{{property.cap_name}}(value); err != nil {
		        return dbus.MakeFailedError(err)
		    }
		}
		c.{{property.lower_name}} = value
		for _, observer := range c.{{property.lower_name}}ChangedObservers {
            go observer.On{{property.cap_name}}Changed(value)
        }
		return nil
	}
}

{% endif %}
{% endfor %}

{% for property in interface.properties %}
{% if not property.readonly %}
func (c *{{interface.cap_name}}Adapter) Add{{property.cap_name}}ChangedObserver(observer interface{ On{{property.cap_name}}Changed({{property.go_type}}) }) {
    c.{{property.lower_name}}ChangedObservers = append(c.{{property.lower_name}}ChangedObservers, observer)
}
func (c *{{interface.cap_name}}Adapter) Remove{{property.cap_name}}ChangedObserver(observer interface{ }) bool {
    found := false
    for i := range c.{{property.lower_name}}ChangedObservers {
        if c.{{property.lower_name}}ChangedObservers[i] == observer {
            c.{{property.lower_name}}ChangedObservers = append(c.{{property.lower_name}}ChangedObservers[:i], c.{{property.lower_name}}ChangedObservers[i+1:]...)
            found = true
        }
     }
     return found
}
{% endif %}
{% endfor %}

{% for signal in interface.signals %}
func (c *{{interface.cap_name}}Adapter) {{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) {
	c.Conn.Emit(c.objectPath, c.interfaceName+".{{signal}}",
    {%- for parameter in signal.parameters -%}{{parameter.name}},{%- endfor -%})
}
{% endfor %}

func (c *{{interface.cap_name}}Adapter) signalsIntrospection() []introspect.Signal {
	t := reflect.TypeOf(c)
	signals := map[string][]string{ {% for signal in interface.signals %}"{{signal.name}}":{
	{%- for parameter in signal.parameters -%}"{{parameter.name}}",{%- endfor -%} },
	{% endfor %} }
	ms := make([]introspect.Signal, 0, len(signals))
    for k, v := range signals {
		signal, b := t.MethodByName(strings.Title(k))
		if !b {
			panic("something wrong in generated code")
		}
		var m introspect.Signal
		m.Name = k
		m.Args = make([]introspect.Arg, 0, signal.Type.NumIn())
		for j, param := range v {
			arg := introspect.Arg{Name: param, Type: dbus.SignatureOfType(signal.Type.In(j + 1)).String(), Direction: "out"}
			m.Args = append(m.Args, arg)
		}
		m.Annotations = make([]introspect.Annotation, 0)
		ms = append(ms, m)
	}
	return ms
}



{% endfor %}

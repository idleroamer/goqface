// Code generated by goqface. DO NOT EDIT.
package {{''.join(module.module.name_parts)|lower}}
import (
	"reflect"
	"strings"
	"errors"
{% for interface in module.interfaces: %}
{% if interface.properties %}
	"log"
{% endif %}
{% endfor %}
	"github.com/godbus/dbus/v5"
	"github.com/godbus/dbus/v5/introspect"
	"github.com/godbus/dbus/v5/prop"
	"github.com/idleroamer/goqface/objectManager"
{% for key, value in module.interface_imports.items() %}
{{key}} "{{value}}"
{% endfor %}
)

{% for interface in module.interfaces: %}

type {{interface.cap_name}}Adapter struct {
    interfaceImpl {{interface.cap_name}}
	Conn           *dbus.Conn
	interfaceName  string
	objectPath     dbus.ObjectPath
	MethodMapping  map[string]string
	Props          *prop.Properties
	PropsSpec      map[string]map[string]*prop.Prop
	exported       bool
}

/*
* init initializes the struct with the proper values
*/
func (c *{{interface.cap_name}}Adapter) Init(v {{interface.cap_name}}) {
    c.interfaceImpl = v
	if c.interfaceName == "" {
    	c.interfaceName = "{{interface.qualified_name}}"
	}
	if c.objectPath == "" {
    	c.objectPath = "/{{interface.qualified_name.replace('.', '/')}}"
	}
    c.MethodMapping = map[string]string{
    {% for operation in interface.operations %}
    "{{operation.cap_name}}": "{{operation.lower_name}}",
    {% endfor %}
    }

    c.PropsSpec = map[string]map[string]*prop.Prop{
		c.interfaceName: {
            {% for property in interface.properties %}
            "{{property.name}}": {
                Value: c.interfaceImpl.{{property.cap_name}}(),
                {% if property.readonly %}
                Writable: false,
                {% else %}
                Writable: true,
                {% endif %}
                Emit: prop.EmitTrue,
                {% if property.readonly %}
                Callback: nil,
                {% else %}
                Callback: set{{property.cap_name}}Callback(c),
                {% endif %}
            },
            {% endfor %}
			// a conventional property to be used on client side to check the connection and readiness of the server
			"ready": {
				Value: c.interfaceImpl.Ready(),
				Writable: false,
				Emit: prop.EmitTrue,
				Callback: nil,
			},
		},
	}
	{% for property in interface.properties %}
	c.interfaceImpl.Add{{property.cap_name}}ChangedObserver(c)
	{% endfor %}
	c.interfaceImpl.AddReadyChangedObserver(c)
	{% for signal in interface.signals %}
	c.interfaceImpl.Add{{signal.cap_name}}Observer(c);
	{% endfor %}
}

func (c *{{interface.cap_name}}Adapter) Export() {
    c.Conn.ExportWithMap(c, c.MethodMapping, c.objectPath, c.interfaceName)
	props, err := prop.Export(c.Conn, c.objectPath, c.PropsSpec)
	c.Props = props
	if err != nil {
		panic(err)
	}
	c.Conn.ExportWithMap(c, map[string]string{"Introspect": "Introspect"}, c.objectPath, "org.freedesktop.DBus.Introspectable")
	goqface.ObjectManager(c.Conn).RegisterObject(c.ObjectPath(), nil)
	c.exported = true
}

func (c *{{interface.cap_name}}Adapter) Close() {
	{% for property in interface.properties %}
	c.interfaceImpl.Remove{{property.cap_name}}ChangedObserver(c)
	{% endfor %}
	c.interfaceImpl.RemoveReadyChangedObserver(c)
	{% for signal in interface.signals %}
	c.interfaceImpl.Remove{{signal.cap_name}}Observer(c);
	{% endfor %}
	
    goqface.ObjectManager(c.Conn).UnregisterObject(c.ObjectPath(), nil)
	// unexport the adapter
	c.Conn.Export(nil, c.objectPath, c.interfaceName)
	c.Conn.Export(nil, c.objectPath, "org.freedesktop.DBus.Properties")
	c.Conn.Export(nil, c.objectPath, "org.freedesktop.DBus.Introspectable")
}

func (c *{{interface.cap_name}}Adapter) ObjectPath() dbus.ObjectPath {
	return c.objectPath
}

func (c *{{interface.cap_name}}Adapter) SetObjectPath(objectPath dbus.ObjectPath) error {
	if !c.exported {
		c.objectPath = objectPath
		return nil
	} else { 
		return errors.New("Can't change object path on an already exporeted object")
	}
}

func (c *{{interface.cap_name}}Adapter) InterfaceName() string {
	return c.interfaceName
}

func (c *{{interface.cap_name}}Adapter) SetInterfaceName(interfaceName string) error {
	if !c.exported {
		c.interfaceName = interfaceName
		return nil
	} else { 
		return errors.New("Can't change interface on an already exporeted object")
	}
}

func (c *{{interface.cap_name}}Adapter) Introspect() (string, *dbus.Error) {
	methods := introspect.Methods(c.interfaceImpl)
    i := 0
    for _, method := range methods {
        mappedName, ok := c.MethodMapping[method.Name]
        if ok {
            method.Name = mappedName
            methods[i] = method
            i++
        }
    }
	methods = methods[:i]
	n := &introspect.Node{
		Name: string(c.objectPath),
		Interfaces: []introspect.Interface{
			introspect.IntrospectData,
			prop.IntrospectData,
			{
				Name:       c.interfaceName,
				Methods:    methods,
				Signals:    c.signalsIntrospection(),
				Properties: c.Props.Introspection(c.interfaceName),
			},
		},
	}
	return string(introspect.NewIntrospectable(n)), nil
}

{% for operation in interface.operations %}
{% if operation.comment %}
{% endif %}
func (c *{{interface.cap_name}}Adapter) {{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}} {{parameter.go_type}},{%- endfor -%}) ({% if operation.has_return_value %}{{operation.go_type}}, {% endif %}*dbus.Error) {
	return c.interfaceImpl.{{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}},{%- endfor -%})
}
{% endfor %}

func (c *{{interface.cap_name}}Adapter) OnReadyChanged (v bool) {
	if c.Props != nil {
    	c.Props.SetMust(c.interfaceName, "ready", v)
	}
}

{% for property in interface.properties %}

func (c *{{interface.cap_name}}Adapter) On{{property.cap_name}}Changed (v {{property.go_type}}) {
	if c.Props != nil {
    	c.Props.SetMust(c.interfaceName, "{{property.name}}", v)
	}
}

{% if not property.readonly %}
func set{{property.cap_name}}Callback(c *{{interface.cap_name}}Adapter) func(change *prop.Change) *dbus.Error {
    return func(change *prop.Change) *dbus.Error {
        var value {{property.go_type}}
		if err := dbus.Store([]interface{}{change.Value}, &value); err != nil {
			return dbus.MakeFailedError(err)
		} else {
			log.Print(err)
		}
		if err := c.interfaceImpl.Set{{property.cap_name}}(value); err != nil {
			return dbus.MakeFailedError(err)
		}
		return nil
	}
}

{% endif %}
{% endfor %}

{% for signal in interface.signals %}
func (c *{{interface.cap_name}}Adapter) On{{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) {
	c.Conn.Emit(c.objectPath, c.interfaceName+".{{signal}}",
    {%- for parameter in signal.parameters -%}{{parameter.name}},{%- endfor -%})
}
{% endfor %}

func (c *{{interface.cap_name}}Adapter) signalsIntrospection() []introspect.Signal {
	t := reflect.TypeOf(c.interfaceImpl)
	signals := map[string][]string{ {% for signal in interface.signals %}"{{signal.name}}":{
	{%- for parameter in signal.parameters -%}"{{parameter.name}}",{%- endfor -%} },
	{% endfor %} }
	ms := make([]introspect.Signal, 0, len(signals))
    for k, v := range signals {
		signal, b := t.MethodByName(strings.Title(k))
		if !b {
			panic("something wrong in generated code")
		}
		var m introspect.Signal
		m.Name = k
		m.Args = make([]introspect.Arg, 0, signal.Type.NumIn())
		for j, param := range v {
			arg := introspect.Arg{Name: param, Type: dbus.SignatureOfType(signal.Type.In(j + 1)).String(), Direction: "out"}
			m.Args = append(m.Args, arg)
		}
		m.Annotations = make([]introspect.Annotation, 0)
		ms = append(ms, m)
	}
	return ms
}

{% endfor %}

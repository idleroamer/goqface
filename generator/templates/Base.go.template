// Code generated by goqface. DO NOT EDIT.
package {{''.join(module.module.name_parts)|lower}}
import (
	"reflect"
{% for interface in module.interfaces: %}
{% if interface.properties %}
{% endif %}
{% endfor %}
{% for key, value in module.base_imports.items() %}
    {{key}} "{{value}}"
{% endfor %}
)

{% for interface in module.interfaces: %}

type {{interface.cap_name}}Base struct {
    interfaceImpl {{interface.cap_name}}
	{% for property in interface.properties %}
	{{property.lower_name}} {{property.go_type}}
	{% endfor %}
	{% for property in interface.properties %}
    {{property.lower_name}}ChangedObservers []interface{ On{{property.cap_name}}Changed( {{property.name}} {{property.go_type}})}
    {% endfor %}
	ready          bool // to be used to query readiness of the server
    readyChangedObservers []interface{ OnReadyChanged( ready bool)}
    {% for signal in interface.signals %}
    {{signal.lower_name}}Observers []interface{ On{{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) }
    {% endfor %}

}

func (c *{{interface.cap_name}}Base) Ready() bool {
    return  c.ready
}

func (c *{{interface.cap_name}}Base) SetReady (value bool) {
	if !reflect.DeepEqual(c.ready, value) {
        c.ready = value
		for _, observer := range c.readyChangedObservers {
            go observer.OnReadyChanged(value)
        }
	}
}

func (c *{{interface.cap_name}}Base) AddReadyChangedObserver(observer interface{ OnReadyChanged(bool) }) {
    found := false
    for i := range c.readyChangedObservers {
        if c.readyChangedObservers[i] == observer {
            found = true
            break;
        }
     }
     if !found {
        c.readyChangedObservers = append(c.readyChangedObservers, observer)
     }
     
}
func (c *{{interface.cap_name}}Base) RemoveReadyChangedObserver(observer interface{ }) bool {
    found := false
    for i := range c.readyChangedObservers {
        if c.readyChangedObservers[i] == observer {
            c.readyChangedObservers = append(c.readyChangedObservers[:i], c.readyChangedObservers[i+1:]...)
            found = true
        }
     }
     return found
}

{% for property in interface.properties %}
func (c *{{interface.cap_name}}Base) {{property.cap_name}}() {{property.go_type}} {
    return c.{{property.lower_name}}
}
func (c *{{interface.cap_name}}Base) Set{{property.cap_name}} (value {{property.go_type}}) error {
	if !reflect.DeepEqual(c.{{property.lower_name}}, value) {
        c.{{property.lower_name}} = value
        for _, observer := range c.{{property.lower_name}}ChangedObservers {
            go observer.On{{property.cap_name}}Changed(value)
        }
    }
    return nil
}

func (c *{{interface.cap_name}}Base) Add{{property.cap_name}}ChangedObserver(observer interface{ On{{property.cap_name}}Changed({{property.go_type}}) }) {
    found := false
    for i := range c.{{property.lower_name}}ChangedObservers {
        if c.{{property.lower_name}}ChangedObservers[i] == observer {
            found = true
            break;
        }
     }
     if !found {
        c.{{property.lower_name}}ChangedObservers = append(c.{{property.lower_name}}ChangedObservers, observer)
     }
     
}
func (c *{{interface.cap_name}}Base) Remove{{property.cap_name}}ChangedObserver(observer interface{ }) bool {
    found := false
    for i := range c.{{property.lower_name}}ChangedObservers {
        if c.{{property.lower_name}}ChangedObservers[i] == observer {
            c.{{property.lower_name}}ChangedObservers = append(c.{{property.lower_name}}ChangedObservers[:i], c.{{property.lower_name}}ChangedObservers[i+1:]...)
            found = true
        }
     }
     return found
}
{% endfor %}

{% for signal in interface.signals %}
func (c *{{interface.cap_name}}Base) {{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) {
	for _, observer := range c.{{signal.lower_name}}Observers {
        go observer.On{{signal.cap_name}}({%- for parameter in signal.parameters -%}{{parameter.name}},{%- endfor -%})
    }
}
{% endfor %}

{% for signal in interface.signals %}
func (c *{{interface.cap_name}}Base) Add{{signal.cap_name}}Observer(observer interface{ On{{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) }) {
    c.{{signal.lower_name}}Observers = append(c.{{signal.lower_name}}Observers, observer)
}
func (c *{{interface.cap_name}}Base) Remove{{signal.cap_name}}Observer(observer interface{ }) bool {
    found := false
    for i := range c.{{signal.lower_name}}Observers {
        if c.{{signal.lower_name}}Observers[i] == observer {
            c.{{signal.lower_name}}Observers = append(c.{{signal.lower_name}}Observers[:i], c.{{signal.lower_name}}Observers[i+1:]...)
            found = true
        }
     }
     return found
}
{% endfor %}

{% endfor %}

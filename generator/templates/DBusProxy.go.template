// Code generated by goqface. DO NOT EDIT.
package {{''.join(module.module.name_parts)|lower}}

import (
{% for interface in module.interfaces: %}
{% if interface.properties %}
    "reflect"
{% endif %}
    "log"
{% endfor %}
	"github.com/godbus/dbus/v5"
	"github.com/idleroamer/goqface/objectManager"
{% for key, value in module.interface_imports.items() %}
{{key}} "{{value}}"
{% endfor %}
)

{% for interface in module.interfaces: %}

type {{interface.proxy_name}} struct {
	{% for property in interface.properties %}
	{{property.lower_name}} {{property.go_type}}
	{% endfor %}
	{% for property in interface.properties %}
	{{property.lower_name}}ChangedObservers []interface{ On{{property.cap_name}}Changed( {{property.name}} {{property.go_type}})}
	{% endfor %}
	readyChangedObservers []interface{ OnReadyChanged( ready bool)}
	{% for signal in interface.signals %}
    {{signal.lower_name}}Observers []interface{ On{{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) }
    {% endfor %}
	ready          bool
	Conn           *dbus.Conn
	serviceName    string
	interfaceName  string
	objectPath     dbus.ObjectPath
	remoteObj      dbus.BusObject
        connected      bool
        explicitService bool

}

func (c *{{interface.proxy_name}}) Init() {
    c.interfaceName = "{{interface.qualified_name}}"
    c.objectPath = "/{{interface.qualified_name.replace('.', '/')}}"
}

func (c *{{interface.proxy_name}}) watchSignals() {
    ch := make(chan *dbus.Signal)
	c.Conn.Signal(ch)
	for v := range ch {
	    if (v.Name == "org.freedesktop.DBus.Properties.PropertiesChanged") {
	        var inter string
	        var changedProps map[string]dbus.Variant
	        var invalidatedProps []string
			err := dbus.Store(v.Body, &inter, &changedProps, &invalidatedProps)
			if err == nil && inter == "{{interface.qualified_name}}" {
                c.setProps(changedProps)
            } else if err != nil {
                log.Print(err)
            }
	    }
	    {% for signal in interface.signals %}
	    if (v.Name == "{{interface.qualified_name}}.{{signal.name}}") {
            {% for param in signal.parameters %}
            var arg{{loop.index}} {{param.go_type}}
            {% endfor %}
            err := dbus.Store(v.Body, {%- for parameter in signal.parameters -%} &arg{{loop.index}},{%- endfor -%})
            if err == nil {
                for _, observer := range c.{{signal.lower_name}}Observers {
                    go observer.On{{signal.cap_name}}({%- for parameter in signal.parameters -%} arg{{loop.index}},{%- endfor -%})
                }
            } else {
                log.Print(err)
            }
	    }
        {% endfor %}
	}
}

func (c *{{interface.proxy_name}}) ConnectToRemoteObject() {
    c.connected = true
    c.setServiceName(c.serviceName)
}

func (c *{{interface.proxy_name}}) ObjectPath() dbus.ObjectPath {
	return c.objectPath
}

func (c *{{interface.proxy_name}}) SetObjectPath(objectPath dbus.ObjectPath) {
    c.objectPath = objectPath
}

func (c *{{interface.proxy_name}}) InterfaceName() string {
	return c.interfaceName
}

func (c *{{interface.proxy_name}}) SetInterfaceName(interfaceName string) {
    c.interfaceName = interfaceName
}

func (c *{{interface.proxy_name}}) ServiceName() string {
	return c.serviceName
}

func (c *{{interface.proxy_name}}) SetServiceName(serviceName string) {
	c.explicitService = true
	c.setServiceName(serviceName)
}

func (c *{{interface.proxy_name}}) setServiceName(serviceName string) {
    c.serviceName = serviceName
    if c.connected {
        if !c.explicitService {
            goqface.ObjectManager(c.Conn).AddInterfacesAddedObserver(c)
            goqface.ObjectManager(c.Conn).AddInterfacesRemovedObserver(c)
            c.serviceName = goqface.ObjectManager(c.Conn).ObjectService(c.objectPath)
            if (c.serviceName != "") {
                c.connectToRemoteObject()
            }
        } else {
            goqface.ObjectManager(c.Conn).RemoveInterfacesAddedObserver(c)
            goqface.ObjectManager(c.Conn).RemoveInterfacesRemovedObserver(c)
            // TODO Watchservice explicitly
            if c.serviceName != "" {
                c.connectToRemoteObject()
            }
        }
    }
}

func (c *{{interface.proxy_name}}) connectToRemoteObject() {
    c.remoteObj = c.Conn.Object(c.serviceName, c.objectPath)
    if err := c.Conn.AddMatchSignal(dbus.WithMatchInterface("org.freedesktop.DBus.Properties"), dbus.WithMatchMember("PropertiesChanged"),
        dbus.WithMatchObjectPath(c.objectPath)); err != nil {
            log.Printf("Failed to watch signal PropertiesChanged of remote-object at path %v with error %v", c.objectPath, err)
        }
    {% for signal in interface.signals %}
    	if err := c.Conn.AddMatchSignal(dbus.WithMatchInterface(c.interfaceName), dbus.WithMatchMember("{{signal.name}}"), 
            dbus.WithMatchObjectPath(c.objectPath)); err != nil {
            log.Printf("Failed to watch signal {{signal.name}} of remote-object at path %v with error %v", c.objectPath, err)
        }
    {% endfor %}
    go c.watchSignals()
    values := c.remoteObj.Call("org.freedesktop.DBus.Properties.GetAll", 0, c.interfaceName)
    if len(values.Body) > 0 {
        props := values.Body[0].(map[string]dbus.Variant)
        c.setProps(props)
    }
}

func (c *{{interface.proxy_name}}) OnInterfacesAdded(serviceName string, objectPath dbus.ObjectPath) {
    if objectPath == c.objectPath {
        if c.serviceName == "" {
            c.setServiceName(serviceName)
        } else if c.serviceName != serviceName {
            log.Printf("Ignore InterfaceAdded by service %s for object %s, already listening on service %s", serviceName, c.objectPath, c.serviceName)
        }
    }
}

func (c *{{interface.proxy_name}}) OnInterfacesRemoved(serviceName string, objectPath dbus.ObjectPath) {
    if objectPath == c.objectPath {
        if serviceName == c.serviceName {
            log.Printf("Object %s at service %s is removed", objectPath, serviceName)
            if c.ready != false {
                c.ready = false
                for _, observer := range c.readyChangedObservers {
                    go observer.OnReadyChanged(c.ready)
                }
            }
        } else {
             log.Printf("Ignore InterfaceRemoved by service %s for object %s, proxy listening on service %s", serviceName, c.objectPath, c.serviceName)
        }
    }
}

func (c *{{interface.proxy_name}}) setProps(props map[string]dbus.Variant) {
    {% for property in interface.properties %}
    if val, ok := props["{{property.name}}"]; ok {
        var t {{property.go_type}}
        err := dbus.Store([]interface{}{val}, &t)
        if err == nil && !reflect.DeepEqual(c.{{property.lower_name}}, t) {
            c.{{property.lower_name}} = t
            for _, observer := range c.{{property.lower_name}}ChangedObservers {
                go observer.On{{property.cap_name}}Changed(c.{{property.lower_name}})
            }
        } else if err != nil {
            log.Print(err)
        }
    }
    {% endfor %}
    if val, ok := props["ready"]; ok {
        var ready bool 
        err := dbus.Store([]interface{}{val}, &ready)
        if err == nil && c.ready != ready {
            c.ready = ready
            for _, observer := range c.readyChangedObservers {
                go observer.OnReadyChanged(c.ready)
            }
        }
    }
}

{% for property in interface.properties %}
func (c *{{interface.proxy_name}}) {{property.cap_name}}() {{property.go_type}} {
    return  c.{{property.lower_name}}
}
{% if not property.readonly %}
func (c *{{interface.proxy_name}}) Set{{property.cap_name}}(value {{property.go_type}}) error {
    return c.remoteObj.SetProperty("{{interface.qualified_name}}.{{property.name}}", dbus.MakeVariant(value))
}
{% endif %}
{% endfor %}
func (c *{{interface.proxy_name}}) Ready() bool {
    return  c.ready
}

{% for property in interface.properties %}
func (c *{{interface.proxy_name}}) Add{{property.cap_name}}ChangedObserver(observer interface{ On{{property.cap_name}}Changed({{property.go_type}}) }) {
    found := false
    for i := range c.{{property.lower_name}}ChangedObservers {
        if c.{{property.lower_name}}ChangedObservers[i] == observer {
            found = true
            break;
        }
     }
     if !found {
        c.{{property.lower_name}}ChangedObservers = append(c.{{property.lower_name}}ChangedObservers, observer)
     }
}
func (c *{{interface.proxy_name}}) Remove{{property.cap_name}}ChangedObserver(observer interface{ }) bool {
    found := false
    for i := range c.{{property.lower_name}}ChangedObservers {
        if c.{{property.lower_name}}ChangedObservers[i] == observer {
            c.{{property.lower_name}}ChangedObservers = append(c.{{property.lower_name}}ChangedObservers[:i], c.{{property.lower_name}}ChangedObservers[i+1:]...)
            found = true
        }
     }
     return found
}
{% endfor %}

func (c *{{interface.proxy_name}}) AddReadyChangedObserver(observer interface{ OnReadyChanged(bool) }) {
    found := false
    for i := range c.readyChangedObservers {
        if c.readyChangedObservers[i] == observer {
            found = true
            break;
        }
    }
    if !found {
        c.readyChangedObservers = append(c.readyChangedObservers, observer)
    }
}
func (c *{{interface.proxy_name}}) RemoveReadyChangedObserver(observer interface{ OnReadyChanged(bool) }) bool {
    found := false
    for i := range c.readyChangedObservers {
        if c.readyChangedObservers[i] == observer {
            c.readyChangedObservers = append(c.readyChangedObservers[:i], c.readyChangedObservers[i+1:]...)
            found = true
        }
     }
     return found
}

{% for signal in interface.signals %}
func (c *{{interface.proxy_name}}) Add{{signal.cap_name}}Observer(observer interface { On{{signal.cap_name}}({%- for parameter in signal.parameters -%} {{parameter.name}} {{parameter.go_type}},{%- endfor -%}) })  {
    c.{{signal.lower_name}}Observers = append(c.{{signal.lower_name}}Observers, observer)
}
func (c *{{interface.proxy_name}}) Remove{{signal.cap_name}}Observer(observer interface{ }) bool {
    found := false
    for i := range c.{{signal.lower_name}}Observers {
        if c.{{signal.lower_name}}Observers[i] == observer {
            c.{{signal.lower_name}}Observers = append(c.{{signal.lower_name}}Observers[:i], c.{{signal.lower_name}}Observers[i+1:]...)
            found = true
        }
     }
     return found
}
{% endfor %}

{% for operation in interface.operations %}
func (c *{{interface.proxy_name}}) {{operation.cap_name}}({%- for parameter in operation.parameters -%}{{parameter.name}} {{parameter.go_type}},{%- endfor -%}) ({% if operation.has_return_value %}r {{operation.go_type}}, {% endif %}err error){
    err=c.remoteObj.Call("{{operation.name}}", 0, {%- for parameter in operation.parameters -%}{{parameter.name}},{%- endfor -%}){% if operation.has_return_value %}.Store(&r){% else %}.Err{% endif %}

    return {% if operation.has_return_value %}r, {% endif %}err
}
{% endfor %}

{% endfor %}
